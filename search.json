[{"path":"/AGENTS.html","id":"id_-project-structure","dir":"","previous_headings":"","what":"üß© Project Structure","title":"NA","text":"R/ ‚Äî R functions man/ ‚Äî roxygen-generated documentation tests/testthat/ ‚Äî unit tests vignettes/ ‚Äî usage guides (knitr) data/ ‚Äî included datasets .github/workflows/ ‚Äî CI pipelines (R CMD check, linting, pkgdown) _pkgdown.yml ‚Äî site configuration (deployed gh-pages)","code":""},{"path":"/AGENTS.html","id":"id_-coding--style-conventions","dir":"","previous_headings":"","what":"üî® Coding & Style Conventions","title":"NA","text":"Language, naming, comments, commit messages English . Use roxygen2 (e.g.¬†#' @param, @return) documentation. Follow tidyverse style: 2-space indent, spaces around operators. Functions variable names snake_case.","code":""},{"path":"/AGENTS.html","id":"id_-core-coding-principles","dir":"","previous_headings":"","what":"‚úÖ Core Coding Principles","title":"NA","text":"Prioritise clarity readability cleverness. Use pure functions clearly defined inputs outputs possible. Follow Single Responsibility Principle ‚Äî function one thing. Avoid code duplication ‚Äî use helper functions factor repeated logic. Use early returns reduce indentation nesting. Avoid deeply nested logic long functions; split logic modular components. Document every exported function consistent roxygen tags. Use @export public functions .","code":""},{"path":"/AGENTS.html","id":"id_-testing","dir":"","previous_headings":"","what":"üìÑ Testing","title":"NA","text":"package uses testthat unit testing: Mirror function names tests/testthat/test-*.R. Use test_that(‚Äúdescription‚Äù, { ‚Ä¶ }) blocks. Prefer multiple small, readable expectations. Mock external data randomness needed repeatability.","code":""},{"path":"/AGENTS.html","id":"id_-pull-request-checklist","dir":"","previous_headings":"","what":"üßπ Pull Request Checklist","title":"NA","text":"AI-generated pull requests meet criteria: clear, descriptive title summary Related issue referenced (applicable) New tests new modified functions Code passes checks Documentation updated (roxygen /vignette) changes CI, versioning, .github/ files unless requested Branch names opened PRs succinct, concise, clear","code":""},{"path":"/AGENTS.html","id":"id_-build--release-workflow","dir":"","previous_headings":"","what":"üì¶ Build & Release Workflow","title":"NA","text":"Update documentation: devtools::document() Run tests: devtools::test() Run package checks: devtools::check()","code":""},{"path":"/AGENTS.html","id":"id_-scope","dir":"","previous_headings":"","what":"üî≠ Scope","title":"NA","text":"Agents must manually edit: man/ .github/ pkgdown/ data/ data-raw/ DESCRIPTION version number Licence authorship information","code":""},{"path":"/AGENTS.html","id":"id_-tone-and-style-guide-for-vignettes","dir":"","previous_headings":"","what":"üìñ Tone and Style Guide for Vignettes","title":"NA","text":"Vignettes aim : Friendly accessible ‚Äî Write ‚Äôre explaining concepts informed non-expert colleague. Accurate precise ‚Äî Technical correctness essential. Avoid oversimplifying core ideas. Narrative structure ‚Äî Use clear logical flow: introduce purpose, explain context, walk examples. Example-driven ‚Äî Use realistic, well-commented examples demonstrate concepts. Wherever possible, relate examples plausible use cases.","code":""},{"path":"/AGENTS.html","id":"do","dir":"","previous_headings":"üìñ Tone and Style Guide for Vignettes","what":"Do:","title":"NA","text":"Use warm, professional tone: ‚ÄúLet‚Äôs explore function works‚Ä¶‚Äù Explain reasoning well code steps. Show intermediate outputs helpful. can use emoji elements help engagement","code":""},{"path":"/AGENTS.html","id":"dont","dir":"","previous_headings":"üìñ Tone and Style Guide for Vignettes","what":"Don‚Äôt:","title":"NA","text":"Assume deep prior knowledge package internals. Use overly casual language. Skip steps leave important arguments unexplained.","code":""},{"path":"/AGENTS.html","id":"voice-checklist","dir":"","previous_headings":"üìñ Tone and Style Guide for Vignettes","what":"Voice checklist:","title":"NA","text":"Conversational professional unexplained acronyms jargon Every code block context interpretation reader feel guided confident, testedTone Style Guide Vignettes","code":""},{"path":"/articles/frontier.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cost-effectiveness frontier","text":"Cost-effectiveness analysis helps us identify interventions provide best value money. cost-effectiveness frontier represents set interventions dominated others‚Äîmeaning intervention provides better outcomes lower cost. vignette demonstrates use frontier() function build cost-effectiveness frontiers data. ‚Äôll explore three key features: Let‚Äôs start creating example data representing different healthcare interventions: dataset contains 50 hypothetical interventions :","code":"Basic frontier identification - finding non-dominated solutions Willingness-to-pay thresholds - filtering by cost-effectiveness criteria Custom constraints - applying additional rules during frontier construction set.seed(12) example <- data.frame(   cost = runif(50, 1, 10) ) example$impact <- 15 + example$cost + rnorm(50) example$group <- sample(c(\"circle\", \"square\"), nrow(example), replace = TRUE) example <- example[order(example$cost), ] example$n <- sample(1:5, nrow(example), replace = TRUE)  # Preview our data head(example) #>        cost   impact  group n #> 10 1.074923 15.70247 circle 1 #> 9  1.205900 15.13541 square 1 #> 6  1.305061 16.97904 circle 5 #> 48 1.412957 15.98355 circle 3 #> 1  1.624248 16.35686 circle 1 #> 46 1.855251 16.32985 circle 5 cost: Implementation cost (arbitrary units) impact: Health impact or effectiveness measure group: Intervention type (for demonstration of custom filters) n: Additional constraint variable"},{"path":"/articles/frontier.html","id":"basic-frontier-analysis","dir":"Articles","previous_headings":"","what":"Basic Frontier Analysis","title":"Cost-effectiveness frontier","text":"simplest use frontier() identifies non-dominated solutions. interventions option provides better impact lower cost: Let‚Äôs visualize . Pink points represent efficient frontier‚Äîbest options:  frontier shows incremental nature cost-effectiveness decisions. step represents intervention costs provides additional impact might justify extra expense. Applying Willingness--Pay Thresholds","code":"frontier_solution <- frontier(example) nrow(frontier_solution)  # Number of frontier solutions #> [1] 7 plot(   example$impact ~ example$cost,   pch = 19,   xlab = \"Cost\",   ylab = \"Impact\",   col = \"grey50\",   main = \"Basic Cost-Effectiveness Frontier\" ) points(frontier_solution$impact ~ frontier_solution$cost, col = \"deeppink\", pch = 19) legend(   \"bottomright\",   legend = c(\"Dominated solutions\", \"Efficient frontier\"),   col = c(\"grey50\", \"deeppink\"),   pch = 19,   bty = \"n\" )"},{"path":"/articles/frontier.html","id":"willingness-to-pay-threshold","dir":"Articles","previous_headings":"","what":"Willingness to pay threshold","title":"Cost-effectiveness frontier","text":"practice, often budget constraints cost-effectiveness thresholds. Incremental Cost-Effectiveness Ratio (ICER) measures additional cost per unit additional impact moving one intervention next. Let‚Äôs apply threshold 1.2 cost units per impact unit:  blue points represent interventions technically frontier exceed cost-effectiveness threshold. don‚Äôt provide enough ‚Äúbang buck‚Äù justify additional cost. crucial policy decisions: even intervention technically efficient, might worth funding cost per unit impact high.","code":"frontier_threshold_solution <- frontier(example, threshold = 1.2) nrow(frontier_threshold_solution)  # Fewer solutions now #> [1] 5 plot(   example$impact ~ example$cost,   pch = 19,   xlab = \"Cost\",   ylab = \"Impact\",   col = \"grey50\",   main = \"Frontier with Willingness-to-Pay Threshold\" ) points(frontier_solution$impact ~ frontier_solution$cost, col = \"dodgerblue\", pch = 19) points(frontier_threshold_solution$impact ~ frontier_threshold_solution$cost, col = \"deeppink\", pch = 19) legend(   \"bottomright\",   legend = c(\"Dominated solutions\", \"Above ICER threshold\", \"Cost-effective frontier\"),   col = c(\"grey50\", \"dodgerblue\", \"deeppink\"),   pch = 19,   bty = \"n\" )"},{"path":"/articles/frontier.html","id":"starting-from-a-specific-point","dir":"Articles","previous_headings":"","what":"Starting from a Specific Point","title":"Cost-effectiveness frontier","text":"Sometimes want evaluate options relative current intervention rather starting cheapest option. start_index parameter lets specify intervention reference point:  turquoise point shows starting intervention. frontier now includes cost-saving options (moving left/) cost-increasing options (moving right/) reference point.","code":"# Let's start from intervention #25 start_index <- 10 frontier_from_start <- frontier(example, start_index = start_index)  plot(   example$impact ~ example$cost,   pch = 19,   xlab = \"Cost\",   ylab = \"Impact\",   col = \"grey50\",   main = \"Frontier Starting from Current Intervention\" ) points(frontier_from_start$impact ~ frontier_from_start$cost, col = \"deeppink\", pch = 19) points(example$impact[start_index] ~ example$cost[start_index], col = \"turquoise\", pch = 19, cex = 1.5) legend(   \"bottomright\",   legend = c(\"Dominated solutions\", \"Cost-effective options\", \"Starting point\"),   col = c(\"grey50\", \"deeppink\", \"turquoise\"),   pch = 19,   bty = \"n\" )"},{"path":"/articles/frontier.html","id":"custom-filtering-rules","dir":"Articles","previous_headings":"","what":"Custom Filtering Rules","title":"Cost-effectiveness frontier","text":"Real-world decisions often involve additional constraints beyond cost-effectiveness. Maybe can switch certain types interventions, regulatory requirements. Custom filter functions let encode rules. ‚Äôs example can move interventions different group: Let‚Äôs visualize different shapes different groups:  Notice frontier now alternates circles squares, respecting constraint can move different intervention type. Understanding Results frontier() function returns original data additional step column: sequential approach mirrors real decision-making: ‚ÄúGiven now, ‚Äôs next best option want spend (less)?‚Äù Practical Tips frontier() function provides flexible framework cost-effectiveness analysis can adapt specific decision-making context maintaining economic rigor.","code":"# Define our constraint: can only move to different intervention types up_filter <- function(options, current) {   options[options$group != current$group, , drop = FALSE] }  frontier_with_rules <- frontier(example, up_filter = up_filter) plot(   example$impact ~ example$cost,   pch = ifelse(example$group == \"circle\", 21, 22),   xlab = \"Cost\",   ylab = \"Impact\",   bg = \"grey50\",   main = \"Frontier with Custom Constraints\" ) points(   frontier_with_rules$impact ~ frontier_with_rules$cost,   bg = \"deeppink\",   pch = ifelse(frontier_with_rules$group == \"circle\", 21, 22),   cex = 1.2 ) legend(   \"bottomright\",   legend = c(\"Circle interventions\", \"Square interventions\", \"Constrained frontier\"),   pch = c(21, 22, 19),   pt.bg = c(\"grey50\", \"grey50\", \"deeppink\"),   col = c(\"black\", \"black\", \"deeppink\"),   bty = \"n\" ) head(frontier_with_rules[, c(\"cost\", \"impact\", \"group\", \"step\")]) #>       cost   impact  group step #> 1 1.074923 15.70247 circle    0 #> 2 1.880677 17.07068 square    1 #> 3 2.609065 19.68110 circle    2 #> 4 5.774298 22.72840 square    3 #> 5 8.593320 24.44909 circle    4 #> 6 8.598034 24.74310 square    5 step = 0: Your starting point Negative steps: Cost-saving moves (moving to cheaper options) Positive steps: Cost-increasing moves (moving to more expensive options) Data preparation: Ensure your cost and impact columns are numeric and represent the outcomes you want to optimize.  Threshold selection: Choose thresholds based on your context. Healthcare often uses GDP per capita or similar economic benchmarks.  Custom filters: Use these for regulatory constraints, feasibility requirements, or strategic preferences.  Starting points: Use current interventions as starting points to make results more actionable for decision-makers."},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Pete Winskill. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Winskill P (2025). om: Optimiation Malaria Budgets. R package version 1.1.3.","code":"@Manual{,   title = {om: Optimiation of Malaria Budgets},   author = {Pete Winskill},   year = {2025},   note = {R package version 1.1.3}, }"},{"path":"/index.html","id":"om-","dir":"","previous_headings":"","what":"Optimiation of Malaria Budgets","title":"Optimiation of Malaria Budgets","text":"om can used find solutions budget-optimisation challenges. might finding optimal mix spatially-targeted intervention packages across country affordable within specified budget envelope. om can also deal optimisations multiple budgets may available different subsets spatial units. example, may want maximise impact global-donor budget optimised across multiple countries, combined contributions domestic budgets country. clever-stuff background handled superb ompr package. Please give appropriate attribution cite ompr package using om (citation(\"ompr\")) sure check ! get started, take look introductory vignette ‚ö†Ô∏è CE frontier functionality WIP - please check outputs Updates, reviews improvements encouraged via PRs! issues clarifications? Please post issues page .","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Optimiation of Malaria Budgets","text":"can install development version om like :","code":"remotes::install_github(\"mrc-ide/om\")"},{"path":"/reference/allocation_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrangle allocations ‚Äî allocation_output","title":"Wrangle allocations ‚Äî allocation_output","text":"Wrangle allocations","code":""},{"path":"/reference/allocation_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrangle allocations ‚Äî allocation_output","text":"","code":"allocation_output(solution, budget)"},{"path":"/reference/allocation_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrangle allocations ‚Äî allocation_output","text":"solution Model solution budget vector budgets","code":""},{"path":"/reference/allocation_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrangle allocations ‚Äî allocation_output","text":"Allocation proportions","code":""},{"path":"/reference/brute.html","id":null,"dir":"Reference","previous_headings":"","what":"Brute force search for single budget level ‚Äî brute","title":"Brute force search for single budget level ‚Äî brute","text":"Brute force search single budget level","code":""},{"path":"/reference/brute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Brute force search for single budget level ‚Äî brute","text":"","code":"brute(z, cost, budget)"},{"path":"/reference/brute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Brute force search for single budget level ‚Äî brute","text":"z Matrix impact. Rows[] = units, cols[j] = options, fill = impact measure. units options, fill z NA. cost Matrix cost. Rows[] = units, cols[j] = options, fill = cost. units options, fill cost NA. budget vector budgets","code":""},{"path":"/reference/brute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Brute force search for single budget level ‚Äî brute","text":"Brute force solution","code":""},{"path":"/reference/build_frontier_down.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Cost-Saving Portion of Frontier ‚Äî build_frontier_down","title":"Build Cost-Saving Portion of Frontier ‚Äî build_frontier_down","text":"Constructs cost-saving (downward) portion cost-effectiveness frontier iteratively selecting solutions best ICERs among cost-saving options. Prioritizes solutions improve impact available, considers cost-saving options impact-improving solutions exist.","code":""},{"path":"/reference/build_frontier_down.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Cost-Saving Portion of Frontier ‚Äî build_frontier_down","text":"","code":"build_frontier_down(x, start_pos, threshold, down_filter)"},{"path":"/reference/build_frontier_down.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Cost-Saving Portion of Frontier ‚Äî build_frontier_down","text":"x data.frame containing ordered cost impact data start_pos Integer. Position starting solution ordered data threshold Numeric. Willingness--pay threshold ICER acceptability down_filter Function. Optional user-defined filter cost-saving candidates","code":""},{"path":"/reference/build_frontier_down.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Cost-Saving Portion of Frontier ‚Äî build_frontier_down","text":"data.frame containing cost-saving frontier solutions step numbers   (negative values indicating cost-saving steps)","code":""},{"path":"/reference/build_frontier_up.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Cost-Increasing Portion of Frontier ‚Äî build_frontier_up","title":"Build Cost-Increasing Portion of Frontier ‚Äî build_frontier_up","text":"Constructs cost-increasing (upward) portion cost-effectiveness frontier iteratively selecting solutions lowest ICERs among options cost provide better impact current solution.","code":""},{"path":"/reference/build_frontier_up.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Cost-Increasing Portion of Frontier ‚Äî build_frontier_up","text":"","code":"build_frontier_up(x, start_pos, threshold, up_filter)"},{"path":"/reference/build_frontier_up.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Cost-Increasing Portion of Frontier ‚Äî build_frontier_up","text":"x data.frame containing ordered cost impact data start_pos Integer. Position starting solution ordered data threshold Numeric. Willingness--pay threshold ICER acceptability up_filter Function. Optional user-defined filter cost-increasing candidates","code":""},{"path":"/reference/build_frontier_up.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Cost-Increasing Portion of Frontier ‚Äî build_frontier_up","text":"data.frame containing cost-increasing frontier solutions step numbers   (positive values indicating cost-increasing steps)","code":""},{"path":"/reference/create_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ompr model ‚Äî create_model","title":"Create ompr model ‚Äî create_model","text":"Create ompr model","code":""},{"path":"/reference/create_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ompr model ‚Äî create_model","text":"","code":"create_model(n, options, z, cost, budget, budget_n, not_recipients, sense)"},{"path":"/reference/create_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ompr model ‚Äî create_model","text":"n Number units options Maximum number options per unit z Matrix impact. Rows[] = units, cols[j] = options, fill = impact measure. units options, fill z NA. cost Matrix cost. Rows[] = units, cols[j] = options, fill = cost. units options, fill cost NA. budget vector budgets budget_n Number budget levels not_recipients Binary matrix indicating units allowed access given budget level sense Optimisation target, can \"min\" \"max\"","code":""},{"path":"/reference/create_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ompr model ‚Äî create_model","text":"ompr model","code":""},{"path":"/reference/frontier.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Cost-Effectiveness Frontier ‚Äî frontier","title":"Build Cost-Effectiveness Frontier ‚Äî frontier","text":"Constructs cost-effectiveness frontier set interventions finding optimal sequence solutions moving (costly) (less costly) specified starting point. algorithm uses incremental cost-effectiveness ratios (ICERs) willingness--pay thresholds determine acceptability.","code":""},{"path":"/reference/frontier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Cost-Effectiveness Frontier ‚Äî frontier","text":"","code":"frontier(   x,   threshold = Inf,   start_index = 1,   up_filter = NULL,   down_filter = NULL )"},{"path":"/reference/frontier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Cost-Effectiveness Frontier ‚Äî frontier","text":"x data.frame containing cost impact data interventions threshold Numeric. Willingness--pay threshold ICER acceptability. Solutions ICERs threshold rejected. Default Inf. start_index Integer. Row index starting solution x. algorithm builds frontier point. Default 1. up_filter Function. Optional user-defined filter function cost-increasing solutions. take arguments (candidates, current) return filtered candidates. down_filter Function. Optional user-defined filter function cost-saving solutions. take arguments (candidates, current) return filtered candidates.","code":""},{"path":"/reference/frontier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Cost-Effectiveness Frontier ‚Äî frontier","text":"data.frame containing frontier solutions additional 'step'   column indicating sequence (negative values cost-saving steps, positive   cost-increasing steps, 0 starting solution).","code":""},{"path":"/reference/matrix_to_idf.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix to indexed data.frame ‚Äî matrix_to_idf","title":"Matrix to indexed data.frame ‚Äî matrix_to_idf","text":"Converts matrix data.frame row () column (j) index variables.","code":""},{"path":"/reference/matrix_to_idf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix to indexed data.frame ‚Äî matrix_to_idf","text":"","code":"matrix_to_idf(x, z = \"z\")"},{"path":"/reference/matrix_to_idf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix to indexed data.frame ‚Äî matrix_to_idf","text":"x Matrix z Name data.frame column storing matrix values","code":""},{"path":"/reference/matrix_to_idf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix to indexed data.frame ‚Äî matrix_to_idf","text":"data.frame","code":""},{"path":"/reference/om.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimise budget ‚Äî om","title":"Optimise budget ‚Äî om","text":"Optimise budget","code":""},{"path":"/reference/om.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimise budget ‚Äî om","text":"","code":"om(z, cost, budget, recipients = NULL, sense = \"max\")"},{"path":"/reference/om.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimise budget ‚Äî om","text":"z Matrix impact. Rows[] = units, cols[j] = options, fill = impact measure. units options, fill z NA. cost Matrix cost. Rows[] = units, cols[j] = options, fill = cost. units options, fill cost NA. budget vector budgets recipients Matrix recipients. Rows[] = units, cols[j] = budget levels, fill = binary indicator show Unit[] access budget[j]. sense Optimisation target, can \"min\" \"max\"","code":""},{"path":"/reference/om.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimise budget ‚Äî om","text":"Optimsised solution","code":""},{"path":"/reference/optimise_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Find solution ‚Äî optimise_model","title":"Find solution ‚Äî optimise_model","text":"Find solution","code":""},{"path":"/reference/optimise_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find solution ‚Äî optimise_model","text":"","code":"optimise_model(model)"},{"path":"/reference/optimise_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find solution ‚Äî optimise_model","text":"model ompr model specified create_model()","code":""},{"path":"/reference/optimise_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find solution ‚Äî optimise_model","text":"Model solution","code":""},{"path":"/reference/output.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrangle solution output ‚Äî output","title":"Wrangle solution output ‚Äî output","text":"Wrangle solution output","code":""},{"path":"/reference/output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrangle solution output ‚Äî output","text":"","code":"output(solution, z_df, cost_df, budget)"},{"path":"/reference/output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrangle solution output ‚Äî output","text":"solution Model solution z_df data.frame z cost_df data.frame cost budget vector budgets","code":""},{"path":"/reference/output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrangle solution output ‚Äî output","text":"Formatted output","code":""},{"path":"/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers ‚Äî tidyeval","title":"Tidy eval helpers ‚Äî tidyeval","text":"page lists tidy eval tools reexported package rlang. learn using tidy eval scripts packages high level, see dplyr programming vignette ggplot2 packages vignette. Metaprogramming section Advanced R may also useful deeper dive. tidy eval operators {{, !!, !!! syntactic constructs specially interpreted tidy eval functions. mostly need {{, !! !!! advanced operators use simple cases. curly-curly operator {{ allows tunnel data-variables passed function arguments inside tidy eval functions. {{ designed individual arguments. pass multiple arguments contained dots, use ... normal way.   enquo() enquos() delay execution one several function arguments. former returns single expression, latter returns list expressions. defused, expressions longer evaluate . must injected back evaluation context !! (single expression) !!! (list expressions).   simple case, code equivalent usage {{ ... . Defusing enquo() enquos() needed complex cases, instance need inspect modify expressions way. .data pronoun object represents current slice data. variable name string, use .data pronoun subset variable [[.   Another tidy eval operator :=. makes possible use glue curly-curly syntax LHS =. technical reasons, R language support complex expressions left =, use := workaround.   Many tidy eval functions like dplyr::mutate() dplyr::summarise() give automatic name unnamed inputs. need create sort automatic names , use as_label(). instance, glue-tunnelling syntax can reproduced manually :   Expressions defused enquo() (tunnelled {{) need simple column names, can arbitrarily complex. as_label() handles cases gracefully. code assumes simple column name, use as_name() instead. safer throws error input name expected.","code":"my_function <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) } my_function <- function(data, var, ...) {   # Defuse   var <- enquo(var)   dots <- enquos(...)    # Inject   data %>%     group_by(!!!dots) %>%     summarise(mean = mean(!!var)) } my_var <- \"disp\" mtcars %>% summarise(mean = mean(.data[[my_var]])) my_function <- function(data, var, suffix = \"foo\") {   # Use `{{` to tunnel function arguments and the usual glue   # operator `{` to interpolate plain strings.   data %>%     summarise(\"{{ var }}_mean_{suffix}\" := mean({{ var }})) } my_function <- function(data, var, suffix = \"foo\") {   var <- enquo(var)   prefix <- as_label(var)   data %>%     summarise(\"{prefix}_mean_{suffix}\" := mean(!!var)) }"},{"path":"/reference/validate_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Input Parameters for Frontier Function ‚Äî validate_inputs","title":"Validate Input Parameters for Frontier Function ‚Äî validate_inputs","text":"Performs comprehensive validation input parameters frontier function, checking data types, required columns, parameter bounds.","code":""},{"path":"/reference/validate_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Input Parameters for Frontier Function ‚Äî validate_inputs","text":"","code":"validate_inputs(x, threshold, start_index)"},{"path":"/reference/validate_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Input Parameters for Frontier Function ‚Äî validate_inputs","text":"x data.frame contain 'cost' 'impact' columns threshold Numeric value representing willingness--pay threshold start_index Integer representing starting row index","code":""},{"path":"/reference/validate_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Input Parameters for Frontier Function ‚Äî validate_inputs","text":"NULL (function stops execution error validation fails)","code":""}]
