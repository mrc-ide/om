---
title: "Cost-effectiveness frontier"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cost-effectiveness frontier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE}
library(om)
```

This vignette demonstrates how to find the cost-effectiveness frontier using
`frontier()`. We'll create a small simulated data set with cost and impact
values and then highlight the solutions that lie on the frontier. We also apply
a *threshold* that limits the maximum cost per unit of impact gained. The World
Health Organization suggests that interventions costing up to 1â€“3 times a
country's GDP per capita for each disability-adjusted life year (DALY) gained
are often considered cost-effective. In our generic example this simply means
setting an upper limit on the cost divided by impact.

```{r}
set.seed(1)
example <- data.frame(
  cost = runif(50, 1, 10)
)
example$impact <- 15 + example$cost + rnorm(50)
example$n <- sample(1:5, nrow(example), replace = TRUE)
```

We can visualise the frontier relative to all generated points. Points that lie
on the frontier are shown in **pink**. Fully dominated solutions are in **grey**.

```{r, fig.width = 6, fig.height = 5}
frontier_solution <- frontier(example)
plot(
  example$impact ~ example$cost,
  pch = 19,
  xlab = "Cost",
  ylab = "Impact",
  col = "grey50"
  )
points(frontier_solution$impact ~ frontier_solution$cost, col = "deeppink", pch = 19)
legend(
  "bottomright",
  legend = c("Dominated solutions", "Efficient frontier"),
  col = c("grey50", "deeppink"),
  pch = 19,
  bty = "n"
)
```

We can also drop dominant solutions that fall outside of a user-specified
ICER threshold, those filtered out by the threshold are coloured **blue**

```{r, fig.width = 6, fig.height = 5}
frontier_threshold_solution <- frontier(example, threshold = 1)
plot(
  example$impact ~ example$cost,
  pch = 19,
  xlab = "Cost",
  ylab = "Impact",
  col = "grey50"
  )
points(frontier_solution$impact ~ frontier_solution$cost, col = "dodgerblue", pch = 19)
points(frontier_threshold_solution$impact ~ frontier_threshold_solution$cost, col = "deeppink", pch = 19)
legend(
  "bottomright",
  legend = c("Dominated solutions", "Efficient frontier", "Above ICER threshold"),
  col = c("grey50", "deeppink", "dodgerblue"),
  pch = 19,
  bty = "n"
)
```

We can also drop dominant solutions that are not on the convex hull of the frontier.
That leaves solutions shown in **Green**

```{r, fig.width = 6, fig.height = 5}
frontier_threshold_solution_hull <- frontier(example, convex_hull = TRUE, threshold = 1)
plot(
  example$impact ~ example$cost,
  pch = 19,
  xlab = "Cost",
  ylab = "Impact",
  col = "grey50"
  )
points(frontier_solution$impact ~ frontier_solution$cost, col = "dodgerblue", pch = 19)
points(frontier_threshold_solution$impact ~ frontier_threshold_solution$cost, col = "deeppink", pch = 19)
points(frontier_threshold_solution_hull$impact ~ frontier_threshold_solution_hull$cost, col = "green", pch = 19)
legend(
  "bottomright",
  legend = c("Dominated solutions", "Extendedly dominated", "Above ICER threshold", "Efficient frontier (convex hull)"),
  col = c("grey50", "deeppink", "dodgerblue", "green"),
  pch = 19,
  bty = "n"
)
```

The convex frontier is the standard approach in cost-effectiveness analysis: it removes extendedly dominated options so that incremental cost-effectiveness ratios (ICERs) increase monotonically. This identifies the minimal set of strategies that could be optimal when interventions are compared sequentially at a given willingness-to-pay threshold.

The full non-dominated set includes all strategies that are not strictly worse than any other. Although some may be extendedly dominated, this view can be more informative when exploring how the set of cost-effective options might change as budgets increase or decrease.

## Starting point

By default the frontier WTP ICER assessment starts from the least costly
frontier solution and moves step-wise up the frontier, in the direction of 
increasing cost solutions. In some cases we may want to specify the starting 
solution and work up and down the frontier from that point. This is done by 
indexing the starting solution in the `frontier()`. This starting solution will 
always be included in the output, even if it does not lie on the frontier.

```{r, fig.width = 6, fig.height = 5}
start_index <- 3
frontier_threshold_solution_start <- frontier(example, threshold = 1, start_index = 3)
plot(
  example$impact ~ example$cost,
  pch = 19,
  xlab = "Cost",
  ylab = "Impact",
  col = "grey50"
  )
points(frontier_solution$impact ~ frontier_solution$cost, col = "dodgerblue", pch = 19)
points(frontier_threshold_solution_start$impact ~ frontier_threshold_solution_start$cost, col = "deeppink", pch = 19)
points(example$impact[start_index] ~ example$cost[start_index], col = "turquoise", pch = 19)
legend(
  "bottomright",
  legend = c("Dominated solutions", "Efficient frontier", "Above ICER threshold", "Starting solution"),
  col = c("grey50", "deeppink", "dodgerblue", "turquoise"),
  pch = 19,
  bty = "n"
)
```

## Custom filtering

We may want to apply other filtering rules when traversing up or down the 
frontier. These may be rules that discard frontier solutions, but that capture
important constraints for a specific analysis. We can define custom filter 
functions to do this and pass them as arguments to the `frontier()` function.
These functions take two arguments: 1) the available solutions and 2) the
current solution. The internal logical can filter available solutions, returning
a filtered set of available solutions. In the example below. we add constraints
based on an additional column in our data (`n`). 

```{r, fig.width = 6, fig.height = 5}
down_filter <- function(down_solutions, current){
  down_solutions[down_solutions$n <= (current$n),]
}
up_filter <- function(up_solutions, current){
  up_solutions[up_solutions$n >= (current$n),]
}


start_index <- 3
frontier_threshold_solution_filter <- frontier(example, threshold = 1,
                                        down_filter = down_filter,
                                        up_filter = up_filter,
                                        start_index = 3)
plot(
  example$impact ~ example$cost,
  pch = 19,
  xlab = "Cost",
  ylab = "Impact",
  col = "grey50"
  )
points(frontier_solution$impact ~ frontier_solution$cost, col = "dodgerblue", pch = 19)
points(frontier_threshold_solution_filter$impact ~ frontier_threshold_solution_filter$cost, col = "deeppink", pch = 19)
points(example$impact[start_index] ~ example$cost[start_index], col = "turquoise", pch = 19)
legend(
  "bottomright",
  legend = c("Dominated solutions", "Efficient frontier", "Above ICER threshold", "Starting soluation"),
  col = c("grey50", "deeppink", "dodgerblue", "turquoise"),
  pch = 19,
  bty = "n"
)

print(frontier_threshold_solution_filter$n)
```


